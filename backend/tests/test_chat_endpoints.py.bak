"""
Comprehensive tests for chat endpoints.

Tests the 3 production-ready chat endpoints:
1. POST /{agent_public_id} - Regular chat
2. POST /{agent_public_id}/stream - SSE streaming chat
3. GET /{agent_public_id}/conversations/{conversation_id} - Conversation history
"""

import pytest
import json
from datetime import datetime
from unittest.mock import patch, AsyncMock, MagicMock
from fastapi.testclient import TestClient
from sqlalchemy.ext.asyncio import AsyncSession

from main import app
from app.models.agent import Agent
from app.models.organization import Organization
from app.models.conversation import Conversation
from app.models.message import Message


@pytest.fixture
def mock_agent():
    """Create a mock agent with organization"""
    org = Organization(
        id=1,
        name="Test Organization",
        slug="test-org",
        plan="pro",
        max_agents=10,
        is_active=True
    )

    agent = Agent(
        id=1,
        name="Test Agent",
        public_id="agent-test-123",
        organization_id=1,
        user_id=1,
        is_active=True,
        domain_expertise_enabled=False
    )
    agent.organization = org

    return agent


@pytest.fixture
def mock_conversation():
    """Create a mock conversation"""
    return Conversation(
        id=1,
        session_id="conv_test_123",
        agent_id=1,
        user_id=None,
        conv_metadata={"visitor_id": "visitor_123"}
    )


@pytest.fixture
def mock_messages():
    """Create mock messages for a conversation"""
    return [
        Message(
            id=1,
            conversation_id=1,
            role="user",
            content="What are your pricing plans?",
            msg_metadata={"sentiment": "neutral"},
            created_at=datetime(2025, 10, 2, 14, 30, 0)
        ),
        Message(
            id=2,
            conversation_id=1,
            role="assistant",
            content="We offer three pricing tiers: Starter, Pro, and Enterprise.",
            msg_metadata={"confidence_score": 0.92, "sources": ["pricing.pdf"]},
            created_at=datetime(2025, 10, 2, 14, 30, 2)
        )
    ]


# ==================== Regular Chat Endpoint Tests ====================

@pytest.mark.asyncio
async def test_regular_chat_success(client, mock_agent):
    """Test successful regular chat request"""

    with patch('app.api.endpoints.chat._authorize_agent_request', return_value=AsyncMock(return_value=mock_agent)):
        with patch('app.api.endpoints.chat._prepare_customer_context') as mock_prepare:
            with patch('app.api.endpoints.chat.RAGService') as mock_rag:
                with patch('app.api.endpoints.chat._save_conversation_message', return_value=AsyncMock()):
                    with patch('app.api.endpoints.chat.check_rate_limit_dependency', return_value=AsyncMock()):
                        # Mock customer context
                        mock_prepare.return_value = {
                            "visitor_id": "visitor_123",
                            "customer_profile_id": 42,
                            "customer_context": MagicMock(
                                confidence_score=0.85,
                                sentiment="positive",
                                named_entities=["pricing"]
                            ),
                            "product_context": {},
                            "analysis": {}
                        }

                        # Mock RAG response
                        mock_rag_instance = AsyncMock()
                        mock_rag_instance.generate_response.return_value = {
                            "response": "We offer three pricing plans...",
                            "sources": [{"source": "pricing.pdf", "relevance_score": 0.92}],
                            "context_used": 5
                        }
                        mock_rag.return_value = mock_rag_instance

                        response = client.post(
                            f"/api/chat/{mock_agent.public_id}",
                            json={
                                "message": "What are your pricing plans?",
                                "user_id": "test_user"
                            },
                            headers={"X-Agent-API-Key": "test_key"}
                        )

                        assert response.status_code == 200
                        data = response.json()
                        assert "response" in data
                        assert "conversation_id" in data
                        assert "sources" in data


@pytest.mark.asyncio
async def test_regular_chat_authentication_required(mock_agent):
    """Test that authentication is required for regular chat"""
    client = TestClient(app)

    response = client.post(
        f"/api/chat/{mock_agent.public_id}",
        json={
            "message": "Test message",
            "user_id": "test_user"
        }
        # No authentication headers
    )

    assert response.status_code in [401, 403]


@pytest.mark.asyncio
async def test_regular_chat_message_validation():
    """Test message validation (1-4000 chars)"""
    client = TestClient(app)

    with patch('app.api.endpoints.chat._authorize_agent_request', return_value=AsyncMock()):
        # Test empty message
        response = client.post(
            "/api/chat/agent-test-123",
            json={
                "message": "",
                "user_id": "test_user"
            },
            headers={"X-Agent-API-Key": "test_key"}
        )
        assert response.status_code == 422

        # Test whitespace-only message
        response = client.post(
            "/api/chat/agent-test-123",
            json={
                "message": "   ",
                "user_id": "test_user"
            },
            headers={"X-Agent-API-Key": "test_key"}
        )
        assert response.status_code == 422

        # Test message too long (> 4000 chars)
        response = client.post(
            "/api/chat/agent-test-123",
            json={
                "message": "a" * 4001,
                "user_id": "test_user"
            },
            headers={"X-Agent-API-Key": "test_key"}
        )
        assert response.status_code == 422


@pytest.mark.asyncio
async def test_regular_chat_rate_limiting(mock_agent):
    """Test rate limiting (10 req/min)"""
    client = TestClient(app)

    with patch('app.api.endpoints.chat._authorize_agent_request', return_value=AsyncMock(return_value=mock_agent)):
        with patch('app.api.endpoints.chat.rate_limiter') as mock_rate_limiter:
            # Mock rate limiter to return limited status
            mock_rate_limiter.is_rate_limited.return_value = (True, 11, 0)

            with patch('app.api.endpoints.chat.check_rate_limit_dependency') as mock_check:
                from fastapi import HTTPException
                mock_check.side_effect = HTTPException(
                    status_code=429,
                    detail={
                        "error": "Rate limit exceeded",
                        "requests_made": 11,
                        "requests_remaining": 0
                    }
                )

                response = client.post(
                    f"/api/chat/{mock_agent.public_id}",
                    json={
                        "message": "Test",
                        "user_id": "test_user"
                    },
                    headers={"X-Agent-API-Key": "test_key"}
                )

                assert response.status_code == 429


@pytest.mark.asyncio
async def test_regular_chat_with_domain_expertise(mock_agent):
    """Test chat with domain expertise enabled"""
    client = TestClient(app)

    # Enable domain expertise
    mock_agent.domain_expertise_enabled = True

    with patch('app.api.endpoints.chat._authorize_agent_request', return_value=AsyncMock(return_value=mock_agent)):
        with patch('app.api.endpoints.chat._prepare_customer_context') as mock_prepare:
            with patch('app.api.endpoints.chat.domain_expertise_service') as mock_domain:
                with patch('app.api.endpoints.chat._save_conversation_message', return_value=AsyncMock()):
                    with patch('app.api.endpoints.chat.check_rate_limit_dependency', return_value=AsyncMock()):
                        mock_prepare.return_value = {
                            "visitor_id": "visitor_123",
                            "customer_profile_id": 42,
                            "customer_context": MagicMock(confidence_score=0.85),
                            "product_context": {},
                            "analysis": {}
                        }

                        mock_domain.answer_with_domain_expertise.return_value = MagicMock(
                            answer="Domain expertise response",
                            confidence_score=0.95,
                            sources=[],
                            grounding_mode="knowledge_based",
                            persona_applied="Enhanced",
                            escalation_suggested=False,
                            web_search_used=False
                        )

                        response = client.post(
                            f"/api/chat/{mock_agent.public_id}",
                            json={
                                "message": "What are your hours?",
                                "user_id": "test_user"
                            },
                            headers={"X-Agent-API-Key": "test_key"}
                        )

                        assert response.status_code == 200
                        data = response.json()
                        assert "response" in data
                        assert data["grounding_mode"] == "knowledge_based"


# ==================== Streaming Chat Endpoint Tests ====================

@pytest.mark.asyncio
async def test_streaming_chat_success(mock_agent):
    """Test successful streaming chat request"""
    client = TestClient(app)

    with patch('app.api.endpoints.chat._authorize_agent_request', return_value=AsyncMock(return_value=mock_agent)):
        with patch('app.api.endpoints.chat._prepare_customer_context') as mock_prepare:
            with patch('app.api.endpoints.chat.RAGService') as mock_rag:
                with patch('app.api.endpoints.chat._save_conversation_message', return_value=AsyncMock()):
                    with patch('app.api.endpoints.chat.check_rate_limit_dependency', return_value=AsyncMock()):
                        mock_prepare.return_value = {
                            "visitor_id": "visitor_123",
                            "customer_profile_id": 42,
                            "customer_context": MagicMock(confidence_score=0.85),
                            "product_context": {},
                            "analysis": {}
                        }

                        # Mock streaming generator
                        async def mock_stream():
                            yield {"type": "metadata", "sources": []}
                            yield {"type": "content", "content": "Hello"}
                            yield {"type": "content", "content": " world"}
                            yield {"type": "done"}

                        mock_rag_instance = AsyncMock()
                        mock_rag_instance.generate_streaming_response.return_value = mock_stream()
                        mock_rag.return_value = mock_rag_instance

                        response = client.post(
                            f"/api/chat/{mock_agent.public_id}/stream",
                            json={
                                "message": "Tell me about your services",
                                "user_id": "test_user"
                            },
                            headers={"X-Agent-API-Key": "test_key"}
                        )

                        assert response.status_code == 200
                        assert response.headers["content-type"] == "text/event-stream; charset=utf-8"


@pytest.mark.asyncio
async def test_streaming_chat_timeout_protection(mock_agent):
    """Test that streaming has 30-second timeout protection"""
    client = TestClient(app)

    with patch('app.api.endpoints.chat._authorize_agent_request', return_value=AsyncMock(return_value=mock_agent)):
        with patch('app.api.endpoints.chat._prepare_customer_context') as mock_prepare:
            with patch('app.api.endpoints.chat.check_rate_limit_dependency', return_value=AsyncMock()):
                with patch('asyncio.timeout') as mock_timeout:
                    mock_prepare.return_value = {
                        "visitor_id": "visitor_123",
                        "customer_profile_id": 42,
                        "customer_context": MagicMock(confidence_score=0.85),
                        "product_context": {},
                        "analysis": {}
                    }

                    # Verify timeout is set
                    response = client.post(
                        f"/api/chat/{mock_agent.public_id}/stream",
                        json={
                            "message": "Test",
                            "user_id": "test_user"
                        },
                        headers={"X-Agent-API-Key": "test_key"}
                    )

                    # Check that timeout was called with 30 seconds
                    # (actual verification depends on implementation details)
                    assert response.status_code == 200


# ==================== Conversation History Endpoint Tests ====================

@pytest.mark.asyncio
async def test_conversation_history_success(mock_agent, mock_conversation, mock_messages):
    """Test successful retrieval of conversation history"""
    client = TestClient(app)

    with patch('app.api.endpoints.chat._authorize_agent_request', return_value=AsyncMock(return_value=mock_agent)):
        with patch('app.api.endpoints.chat.db') as mock_db:
            # Mock conversation query
            conv_result = AsyncMock()
            conv_result.scalar_one_or_none.return_value = mock_conversation

            # Mock messages query
            msg_result = AsyncMock()
            msg_result.scalars.return_value.all.return_value = mock_messages

            mock_db_instance = AsyncMock()
            mock_db_instance.execute.side_effect = [conv_result, msg_result]

            with patch('app.api.endpoints.chat.get_async_db', return_value=mock_db_instance):
                response = client.get(
                    f"/api/chat/{mock_agent.public_id}/conversations/conv_test_123",
                    headers={"X-Agent-API-Key": "test_key"}
                )

                assert response.status_code == 200
                data = response.json()
                assert isinstance(data, list)
                assert len(data) == 2
                assert data[0]["role"] == "user"
                assert data[1]["role"] == "assistant"
                assert "timestamp" in data[0]
                assert "metadata" in data[0]


@pytest.mark.asyncio
async def test_conversation_history_not_found(mock_agent):
    """Test 404 when conversation doesn't exist"""
    client = TestClient(app)

    with patch('app.api.endpoints.chat._authorize_agent_request', return_value=AsyncMock(return_value=mock_agent)):
        with patch('app.api.endpoints.chat.db') as mock_db:
            # Mock empty result (conversation not found)
            conv_result = AsyncMock()
            conv_result.scalar_one_or_none.return_value = None

            mock_db_instance = AsyncMock()
            mock_db_instance.execute.return_value = conv_result

            with patch('app.api.endpoints.chat.get_async_db', return_value=mock_db_instance):
                response = client.get(
                    f"/api/chat/{mock_agent.public_id}/conversations/nonexistent_conv",
                    headers={"X-Agent-API-Key": "test_key"}
                )

                assert response.status_code == 404
                assert "not found" in response.json()["detail"].lower()


@pytest.mark.asyncio
async def test_conversation_history_authentication_required(mock_agent):
    """Test that authentication is required for conversation history"""
    client = TestClient(app)

    response = client.get(
        f"/api/chat/{mock_agent.public_id}/conversations/conv_test_123"
        # No authentication headers
    )

    assert response.status_code in [401, 403]


@pytest.mark.asyncio
async def test_conversation_history_chronological_order(mock_agent, mock_conversation):
    """Test that messages are returned in chronological order"""
    client = TestClient(app)

    # Create messages with specific timestamps
    messages_unordered = [
        Message(
            id=3,
            conversation_id=1,
            role="assistant",
            content="Response 2",
            created_at=datetime(2025, 10, 2, 14, 32, 0)
        ),
        Message(
            id=1,
            conversation_id=1,
            role="user",
            content="Question 1",
            created_at=datetime(2025, 10, 2, 14, 30, 0)
        ),
        Message(
            id=2,
            conversation_id=1,
            role="assistant",
            content="Response 1",
            created_at=datetime(2025, 10, 2, 14, 31, 0)
        )
    ]

    with patch('app.api.endpoints.chat._authorize_agent_request', return_value=AsyncMock(return_value=mock_agent)):
        with patch('app.api.endpoints.chat.db') as mock_db:
            conv_result = AsyncMock()
            conv_result.scalar_one_or_none.return_value = mock_conversation

            msg_result = AsyncMock()
            # Assume query already ordered by created_at
            msg_result.scalars.return_value.all.return_value = sorted(
                messages_unordered,
                key=lambda x: x.created_at
            )

            mock_db_instance = AsyncMock()
            mock_db_instance.execute.side_effect = [conv_result, msg_result]

            with patch('app.api.endpoints.chat.get_async_db', return_value=mock_db_instance):
                response = client.get(
                    f"/api/chat/{mock_agent.public_id}/conversations/conv_test_123",
                    headers={"X-Agent-API-Key": "test_key"}
                )

                assert response.status_code == 200
                data = response.json()

                # Verify chronological order
                timestamps = [msg["timestamp"] for msg in data]
                assert timestamps == sorted(timestamps)


# ==================== Integration Tests ====================

@pytest.mark.integration
@pytest.mark.asyncio
async def test_end_to_end_conversation_flow(mock_agent, mock_conversation):
    """Test complete flow: chat -> save -> retrieve history"""
    client = TestClient(app)

    conversation_id = "conv_integration_test"

    # Step 1: Send chat message
    with patch('app.api.endpoints.chat._authorize_agent_request', return_value=AsyncMock(return_value=mock_agent)):
        with patch('app.api.endpoints.chat._prepare_customer_context') as mock_prepare:
            with patch('app.api.endpoints.chat.RAGService') as mock_rag:
                with patch('app.api.endpoints.chat._save_conversation_message', return_value=AsyncMock()) as mock_save:
                    with patch('app.api.endpoints.chat.check_rate_limit_dependency', return_value=AsyncMock()):
                        mock_prepare.return_value = {
                            "visitor_id": "visitor_123",
                            "customer_profile_id": 42,
                            "customer_context": MagicMock(confidence_score=0.85),
                            "product_context": {},
                            "analysis": {}
                        }

                        mock_rag_instance = AsyncMock()
                        mock_rag_instance.generate_response.return_value = {
                            "response": "Test response",
                            "sources": [],
                            "context_used": 3
                        }
                        mock_rag.return_value = mock_rag_instance

                        chat_response = client.post(
                            f"/api/chat/{mock_agent.public_id}",
                            json={
                                "message": "Test question",
                                "conversation_id": conversation_id,
                                "user_id": "test_user"
                            },
                            headers={"X-Agent-API-Key": "test_key"}
                        )

                        assert chat_response.status_code == 200

                        # Verify conversation was saved
                        mock_save.assert_called_once()


@pytest.mark.asyncio
async def test_organization_data_loaded(mock_agent):
    """Test that agent.organization is properly loaded (not MockOrganization)"""
    client = TestClient(app)

    with patch('app.api.endpoints.chat._authorize_agent_request', return_value=AsyncMock(return_value=mock_agent)):
        with patch('app.api.endpoints.chat._prepare_customer_context') as mock_prepare:
            with patch('app.api.endpoints.chat.domain_expertise_service') as mock_domain:
                with patch('app.api.endpoints.chat._save_conversation_message', return_value=AsyncMock()):
                    with patch('app.api.endpoints.chat.check_rate_limit_dependency', return_value=AsyncMock()):
                        mock_agent.domain_expertise_enabled = True

                        mock_prepare.return_value = {
                            "visitor_id": "visitor_123",
                            "customer_profile_id": 42,
                            "customer_context": MagicMock(confidence_score=0.85),
                            "product_context": {},
                            "analysis": {}
                        }

                        mock_domain.answer_with_domain_expertise.return_value = MagicMock(
                            answer="Response",
                            confidence_score=0.95,
                            sources=[]
                        )

                        response = client.post(
                            f"/api/chat/{mock_agent.public_id}",
                            json={
                                "message": "Test",
                                "user_id": "test_user"
                            },
                            headers={"X-Agent-API-Key": "test_key"}
                        )

                        assert response.status_code == 200

                        # Verify organization was passed (not MockOrganization)
                        call_args = mock_domain.answer_with_domain_expertise.call_args
                        assert call_args[1]["organization"] == mock_agent.organization
                        assert isinstance(call_args[1]["organization"], Organization)


# ==================== Error Handling Tests ====================

@pytest.mark.asyncio
async def test_chat_handles_rag_service_error(mock_agent):
    """Test graceful error handling when RAG service fails"""
    client = TestClient(app)

    with patch('app.api.endpoints.chat._authorize_agent_request', return_value=AsyncMock(return_value=mock_agent)):
        with patch('app.api.endpoints.chat._prepare_customer_context') as mock_prepare:
            with patch('app.api.endpoints.chat.RAGService') as mock_rag:
                with patch('app.api.endpoints.chat.check_rate_limit_dependency', return_value=AsyncMock()):
                    mock_prepare.return_value = {
                        "visitor_id": "visitor_123",
                        "customer_profile_id": 42,
                        "customer_context": MagicMock(confidence_score=0.85),
                        "product_context": {},
                        "analysis": {}
                    }

                    # Simulate RAG service error
                    mock_rag_instance = AsyncMock()
                    mock_rag_instance.generate_response.side_effect = Exception("RAG service error")
                    mock_rag.return_value = mock_rag_instance

                    response = client.post(
                        f"/api/chat/{mock_agent.public_id}",
                        json={
                            "message": "Test",
                            "user_id": "test_user"
                        },
                        headers={"X-Agent-API-Key": "test_key"}
                    )

                    # Should still return 200 with error message in response
                    assert response.status_code in [200, 500]


@pytest.mark.asyncio
async def test_streaming_chat_handles_timeout(mock_agent):
    """Test that streaming properly handles timeout errors"""
    client = TestClient(app)

    with patch('app.api.endpoints.chat._authorize_agent_request', return_value=AsyncMock(return_value=mock_agent)):
        with patch('app.api.endpoints.chat._prepare_customer_context') as mock_prepare:
            with patch('app.api.endpoints.chat.check_rate_limit_dependency', return_value=AsyncMock()):
                import asyncio

                mock_prepare.return_value = {
                    "visitor_id": "visitor_123",
                    "customer_profile_id": 42,
                    "customer_context": MagicMock(confidence_score=0.85),
                    "product_context": {},
                    "analysis": {}
                }

                # Mock timeout scenario
                with patch('asyncio.timeout') as mock_timeout:
                    mock_timeout.side_effect = asyncio.TimeoutError()

                    response = client.post(
                        f"/api/chat/{mock_agent.public_id}/stream",
                        json={
                            "message": "Test",
                            "user_id": "test_user"
                        },
                        headers={"X-Agent-API-Key": "test_key"}
                    )

                    # Should handle timeout gracefully
                    assert response.status_code in [200, 408, 504]


# ==================== Performance Tests ====================

@pytest.mark.performance
@pytest.mark.asyncio
async def test_chat_response_time(mock_agent):
    """Test that chat response time is within acceptable limits"""
    import time
    client = TestClient(app)

    with patch('app.api.endpoints.chat._authorize_agent_request', return_value=AsyncMock(return_value=mock_agent)):
        with patch('app.api.endpoints.chat._prepare_customer_context') as mock_prepare:
            with patch('app.api.endpoints.chat.RAGService') as mock_rag:
                with patch('app.api.endpoints.chat._save_conversation_message', return_value=AsyncMock()):
                    with patch('app.api.endpoints.chat.check_rate_limit_dependency', return_value=AsyncMock()):
                        mock_prepare.return_value = {
                            "visitor_id": "visitor_123",
                            "customer_profile_id": 42,
                            "customer_context": MagicMock(confidence_score=0.85),
                            "product_context": {},
                            "analysis": {}
                        }

                        mock_rag_instance = AsyncMock()
                        mock_rag_instance.generate_response.return_value = {
                            "response": "Quick response",
                            "sources": [],
                            "context_used": 3
                        }
                        mock_rag.return_value = mock_rag_instance

                        start_time = time.time()

                        response = client.post(
                            f"/api/chat/{mock_agent.public_id}",
                            json={
                                "message": "Test",
                                "user_id": "test_user"
                            },
                            headers={"X-Agent-API-Key": "test_key"}
                        )

                        elapsed_time = time.time() - start_time

                        assert response.status_code == 200
                        # Response should be fast with mocked services
                        assert elapsed_time < 1.0  # 1 second max for mocked test


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])
